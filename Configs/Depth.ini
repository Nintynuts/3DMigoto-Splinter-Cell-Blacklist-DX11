; [HUD elements at Depth]
; There are several types of element we want to push to depth (after depth map is complete):
; - Light flare: Drawn at screen depth so we use the depth buffer to push each to depth.
;                Accesses the depth buffer directly via a different mechanism.
; - Intel:       These have text drawn before sprites and before other markers.
;                We use the previous frame's behaviour to include this text each frame.
; - Centre goal: These have text and several sprites. 
;                The text is drawn mid-way so we know it's included.
;                It ends with a single blob.
; - Edge goal:   These are like centre goals, but have an extra arrow sprite and no text.
;                They have 2 blobs drawn at the end because of the arrow.
; - Execute:     These are 3 simple sprites drawn in order, but the depth is sampled
;                below to try and hit the target, instead of going over their head.
; - Crosshair:   Sprites which always use the depth from the middle(ish) of the screen.
;
; With the exception of light flares, these are all 'Markers'. 
;
; The philosophy is to sample depth with a custom shader to a custom resource, then 
; re-use that same depth value for all parts of a marker until a known endpoint is 
; reached for that marker. 
;
; To that end, we have StartDepth, UseDepth and EndDepth which are triggered when 
; appropriate by TextureOverrides for sprites and ShaderOverrides for text, 
; because text textures are generated at runtime and don't have a fixed hash.
;
; Both text and sprites can be batched, meaning up to 24 quads can be drawn in one draw call.
; For sprites, we calculate the depth for each quad in the batch, and hope that subsequent 
; batches are drawn in the same order to re-use the depth with the same ordering. 
;
; Text is usually drawn twice, first a blurred background and then the crisp foreground.
; Each draw call is made up of several quads, each an individual character.
; Batching and splitting are issues that needs lots of logic to handle. 
; Batched text can drawn more than one marker at once. Character lengths are cached 
; in a buffer and 'array' when text is not split to be recalled when it is.
; Splitting is quite random and affects both batched and unbatched text. This presents 
; in multiple forms, front split and back split, where 3 draw calls will occur. Sometimes
; this will be half character splits which are easy to detect, and sometimes it will be 
; even splits, which require waiting for the next draw call to make a decision.

[Constants]
global $show_depth = 0
; Variables to keep track of what's happening
global $depth_map = 0
global $allow_depth = 0
global $at_depth = 0
; general counters
global $sprites_before_markers = 0
global $sprites_before_markers_prev = 0
global $counter = 0
global $texts = 0
global $markers = 0
global $intel = 0
global $intel_prev = 0
global $goals = 0
global $goal_arrows = 0
global $executes = 0
global $crosshairs = 0
; text variables
global $new_chars = 0
global $is_front_text = 0
global $chars_temp = 0
global $chars = 0
global $chars_front = 0
global $chars_back = 0
global $new_texts = 0
global $new_texts_front = 0
global $new_texts_back = 0
global $is_goal = 0
global $unknown_chars = 0
global $unknown_is_goal = 0
global $unknown_batched = 0
global $texts_drawn = 0
global $extra_drawn = 0
global $chars_per_batch = 0
global $batched_intel_text = 0
global $text_cache_prev = 0
; sprite variables
global $new_sprites = 0
global $blobs = 0
global $req_blobs = 0
; Special cases for custom shader
global $batched = 0
global $text = 0
global $marker_type = 0
global $crosshair = 1
global $execute = 2
; for debugging (not changed)
global $front_back_match = 1
global $split_back_front = 1
global $split_front_1 = 1
global $split_front_2 = 1
global $split_back = 0
global $back = 0
global $pre = 0

[Present]
post run = CommandList_Reset

[CommandList_Reset]
; process last frame behaviour
if ($unknown_chars > 0)
    run = CommandList_SaveUnknownChars_Pre
endif
$sprites_before_markers_prev = $sprites_before_markers
$sprites_before_markers = 0

$intel_prev = $intel
$intel = 0

; reset counters
$at_depth = 0
$depth_map = 0
$texts = 0
$markers = 0
$goals = 0
$goal_arrows = 0
$blobs = 0
$executes = 0
$crosshairs = 0
$chars = 0
$chars_front = 0
$chars_back = 0
$texts_drawn = 0
$extra_drawn = 0
;Resource\Addons\Debug_CB.ini\DebugCB = copy ResourceDepthValue
;dump = dump_rt jpg mono o0
;run = CommandList\Configs\Array.ini\Clear
;clear = ResourceDepthValue

[KeyToggleDepth]
type = cycle
key = VK_OEM_2
$show_depth = 1, 0 


[ResourceDepthBuffer]

[ResourceMatrices]

[Resource1x1]
type = Texture2D
width = 1
height = 1
format = R32_FLOAT
mips = 1
array = 1
msaa = 1

[ResourceDepthValue]
type = RWStructuredBuffer
stride = 16
array = 16

[CommandList_UseDepthBuffer_Both]
pre vs-t10 = ResourceDepthBuffer
post vs-t10 = null

[CommandList_SetDepthVariables_Both]
run = CommandList_UseDepthBuffer_Both
pre vs-cb11 = ResourceMatrices
post vs-cb11 = null

[CustomShader_SampleDepth_Pre]
vs = ShaderFixes/depth_adjust_quad_vs.hlsl
ps = ShaderFixes/depth_adjust_quad_ps.hlsl
run = CommandList_CalculateDepth_Pre

[CustomShader_SampleDepthBatched_Pre]
vs = ShaderFixes/depth_adjust_quad_vs_batched.hlsl
ps = ShaderFixes/depth_adjust_quad_ps.hlsl
run = CommandList_CalculateDepth_Pre

[CommandList_CalculateDepth_Pre]
run = BuiltInCommandListUnbindAllRenderTargets
; marker_index
y3 = $markers
; marker_type
w3 = $marker_type
; new_chars
$\Configs\Array.ini\index = $texts
run = CommandList\Configs\Array.ini\Get
x4 = $\Configs\Array.ini\value
; run custom shader
vs-t13 = copy vb0
ps-cb11 = ResourceMatrices
ps-t10 = ResourceDepthBuffer
; must set o0 BEFORE ps-u*
o0 = set_viewport Resource1x1
ps-u1 = ResourceDepthValue
draw = from_caller

[CommandList_CalculateDepth_Post]
; marker_index
y3 = 0
; marker_type
w3 = 0
; new_chars
x4 = 0
; must set o0 BEFORE ps-u*
ps-u1 = null

[ShaderOverride_DepthSourceShadowBlur]
hash = 60187e629aa8f9cd
;post ResourceDepthBuffer = stereo2mono ps-t1
post ResourceDepthBuffer = ps-t1
post ResourceMatrices = copy ps-cb11
post $depth_map = 1
run = CommandList_DisplayDepth

[CommandList_DisplayDepth]
if ($show_depth)
    ;Resource\Addons\Debug_2D.ini\Debug2D = ResourceDepthBuffer
else
    ;Resource\Addons\Debug_2D.ini\Debug2D = null
endif

[CommandList_SampleDepth_Pre]
if ($batched)
    run = CustomShader_SampleDepthBatched_Pre
else
    run = CustomShader_SampleDepth_Pre
endif
$at_depth = $new_sprites

[CommandList_StartDepth_Both]
if ($allow_depth && !$at_depth && $pre)
    pre run = CommandList_SampleDepth_Pre
endif
run = CommandList_UseDepth_Both
if (!$pre)
    post run = CommandList_CalculateDepth_Post
endif

[CommandList_UseDepth_Both]
if ($pre)
    pre run = CommandList_UseDepth_Pre
else if (!$pre)
    post run = CommandList_UseDepth_Post
endif

[CommandList_UseDepth_Pre]
if ($allow_depth && $at_depth)
    ; use_depth
    x3 = $at_depth
    ; marker_index
    y3 = $markers
    ; marker_type
    w3 = $marker_type
    vs-t14 = ResourceDepthValue
endif

[CommandList_UseDepth_Post]
if ($allow_depth && $at_depth)
    ; use_depth
    x3 = 0
    ; marker_index
    y3 = 0
    ; marker_type
    w3 = 0
    vs-t14 = null
    ;dump = dump_rt jpg mono o0
endif

[CommandList_EndDepth_Post]
if ($allow_depth && $at_depth)
    ; If we had a marker without text
    ; if ($texts < $markers)
    ; 	$text = $markers
    ; 	$\Configs\Array.ini\index = $markers
    ; 	$\Configs\Array.ini\value = 0
    ; 	run = CommandList\Configs\Array.ini\Set
    ; endif
    $markers = $markers + $new_sprites
    $at_depth = 0
    $texts_drawn = 0
endif

[ShaderOverride_LightFlares]
hash = c4c52320554d1ee9
run = CommandList_UseDepthBuffer_Both
pre vs-t13 = copy vb0
post vs-t13 = null

[CommandList_TextBatched_Pre]
; get cached number of characters
$\Configs\Array.ini\index = $texts + $new_texts
run = CommandList\Configs\Array.ini\Get
; avoid stack overflow if no more recorded character counts
if ($\Configs\Array.ini\value != 0)
    ; deduct cached length from element count to get remainder
    $chars_temp = $chars_temp - $\Configs\Array.ini\value
    if ($chars_temp >= 0)
        $new_texts = $new_texts + 1
    endif
    if ($chars_temp > 0)
        ; repeat for more text for next goal
        run = CommandList_TextBatched_Pre
    else if ($chars_temp < 0)
        ; partial batch, wait for next draw call
        $extra_drawn = $extra_drawn + 1
    endif
endif

[CommandList_TextInner_Pre]
$texts_drawn = $texts_drawn + 1
$new_texts = 0
; append new chars to previous (in case it was partial)
$chars = $chars + $new_chars
; if ($batched)
; 	$chars_temp = $chars
; 	run = CommandList_TextBatched_Pre
; else 
if ($chars % 1 == 0)
    $new_texts = $new_texts + 1
endif

; [CommandList_CacheTextBatched_Pre]
; $\Configs\Array.ini\index = $counter
; $\Configs\Array.ini\value = $chars_per_batch
; run = CommandList\Configs\Array.ini\Set
; $counter = $counter + 1
; if ($counter < ($at_depth + $markers))
; 	run = CommandList_CacheTextBatched_Pre
; endif

[CommandList_CacheText_Pre]
$\Configs\Array.ini\index = $texts
run = CommandList\Configs\Array.ini\Get
$text_cache_prev = $\Configs\Array.ini\value
if ($at_depth == 1)
    ; drawing text for single goal, save the number of characters
    $\Configs\Array.ini\index = $texts
    $\Configs\Array.ini\value = $chars
    run = CommandList\Configs\Array.ini\Set
    ;else
    ;	$chars_per_batch = $chars / $at_depth
    ;	$counter = $markers
    ;	run = CommandList_CacheTextBatched_Pre
endif
$chars = $text_cache_prev
if ($at_depth > 1)
    $\Configs\Array.ini\index = $texts + 1
    run = CommandList\Configs\Array.ini\Get
    $chars = $chars + $\Configs\Array.ini\value
endif
if ($new_chars > $chars)
    $batched_intel_text = $new_chars - $chars
endif
if (!$is_goal)
    $intel = $intel + $new_texts
else if ($new_texts > 1 && $at_depth == 1)
    $new_texts = 1
endif
$texts = $texts + $at_depth
$chars = 0
$chars_front = 0
$chars_back = 0
$new_texts_back = 0
$texts_drawn = 0
$extra_drawn = 0
$new_texts = 0

[CommandList_SaveUnknownChars_Pre]
$chars_temp = $is_goal
$is_goal = $unknown_is_goal
$chars = $unknown_chars
$new_texts = 1
run = CommandList_CacheText_Pre
$unknown_chars = 0
$is_goal = $chars_temp

[CommandList_TextFrontOrBack_Pre]
; Text usually alternates back/front, but sometimes the front or back can be split:
; - complete back + split front where pt1 != pt2 with partials
; - complete back + split front where pt1 != pt2
; - complete back + split front where pt1 == pt2
; - split back where pt1 != pt2 with partials + complete front
; - split back where pt1 != pt2 + complete front
; - split back where pt1 == pt2 + complete front
; We don't know if a back is complete until draw 3 because it could be back + front pt1 could be back pt1 + pt2:
; a + b == c : back split
; a == b + c : front split
; But we can validate using the previous frame totals, so:
; a == a(prev) : complete back
; a + b == a(prev) : split back
; But then sometimes batched text can include multiple texts from separate markers, 
; so we also compare the cache summed with the following text.
; However marker text might change, so the cache isn't 100% reliable.

$new_chars = vertex_count / 6

if ($unknown_chars != 0 && ($chars_back != $new_chars || $unknown_batched != $batched))
    ; last text was not split, so update cache like we would have for last text as new
    run = CommandList_SaveUnknownChars_Pre
endif
; retrieve the number of chars from this index text on the last frame
$\Configs\Array.ini\index = $texts
run = CommandList\Configs\Array.ini\Get
$chars_temp = $\Configs\Array.ini\value
if ($chars_back == 0)
    ; First text, it's the back
    $is_front_text = $back
else if (!$extra_drawn)
    ; Second text
    if ($chars_back % 1 != 0 && $new_chars % 1 != 0)
        ; previous and current have partial chars
        $is_front_text = $split_back
        $extra_drawn = 1
    else if ($chars_back == $new_chars)
        ; front matches back
        if ($new_chars == $chars_temp)
            ; matches last frame
            $is_front_text = $front_back_match
            $unknown_chars = 0
        else
            ; text might be new or back split evenly, so wait for next text
            $unknown_chars = $new_chars
            $unknown_is_goal = $is_goal
            $unknown_batched = $batched
            $is_front_text = $split_back
            $extra_drawn = 1
        endif
    else
        ; split, either back pt 2 or front pt 1, assume the latter to keep the numbers separate
        $is_front_text = $split_front_1
        $extra_drawn = 1
    endif
else
    ; Third text
    if ($chars_front > 0 && $chars_back == $chars_front + $new_chars)
        ; front split pt 2
        $is_front_text = $split_front_2
    else if ($chars_front > 0 && $chars_back + $chars_front == $new_chars)
        ; front of back split
        $is_front_text = $split_back_front
        $chars_back = $chars_back + $chars_front
        ; front will be added on later
        $chars_front = 0
    else
        $\Configs\Array.ini\index = $\Configs\Array.ini\index + 1
        run = CommandList\Configs\Array.ini\Get
        if ($new_chars % 1 != 0 || $chars_back == $chars_temp || ($batched && $chars_back == ($chars_temp + $\Configs\Array.ini\value)))
            ; front split pt 1 (back matches previous frame or the includes the next text)
            $is_front_text = $split_front_1
        else
            $is_front_text = $split_back
        endif
    endif
endif
if ($is_front_text)
    $chars = $chars_front
    $new_texts = $new_texts_front
else
    $chars = $chars_back
    $new_texts = $new_texts_back
endif
; pass partial num_chars to shader
z3 = $chars
x4 = $new_chars
run = CommandList_UseDepth_Pre
run = CommandList_TextInner_Pre

[CommandList_TextFrontOrBack_Post]
z3 = 0
x4 = 0
post run = CommandList_UseDepth_Post
; if text for a marker is complete
if ($is_front_text && $chars == $chars_back && $texts_drawn == (2 + $extra_drawn))
    run = CommandList_CacheText_Pre
    $new_chars = 0
endif
if ($is_front_text)
    $chars_front = $chars
    $new_texts_front = $new_texts
else
    $chars_back = $chars
    $new_texts_back = $new_texts
endif
$chars = 0

[CommandList_TextIsGoal_Both]
; text while at depth is part of a centre goal
; ($texts - $intel) < ($goals - $goal_arrows) && 
if ($at_depth)
    pre run = CommandList_TextFrontOrBack_Pre
    post run = CommandList_TextFrontOrBack_Post
else if ($intel < $intel_prev && ($sprites_before_markers == $sprites_before_markers_prev || $markers))
    ; assume we're at depth
    pre $at_depth = 1
    pre $is_goal = 0
    pre run = CommandList_TextFrontOrBack_Pre
    post run = CommandList_TextFrontOrBack_Post
endif

[CommandList_TextAtDepth_Both]
pre $allow_depth = $depth_map
if ($allow_depth)
    run = CommandList_TextIsGoal_Both
endif
post $allow_depth = 0
; post dump = dump_rt jps o0

[ShaderOverride_Text]
hash = 6f56e2eb15c63f14
allow_duplicate_hash = true
$text = 1
$batched = 0
run = CommandList_TextAtDepth_Both

[ShaderOverride_TextBatched]
hash = 9fe114e79584a0ac
allow_duplicate_hash = true
$text = 1
$batched = 1
run = CommandList_TextAtDepth_Both
post $batched = 0

[CommandList_Sprite_Both]
pre $new_sprites = vertex_count / 6
pre $allow_depth = $depth_map
pre $pre = 1
post $pre = 0
checktextureoverride = ps-t0
post $allow_depth = 0
post $new_sprites = 0

[ShaderOverride_Sprites]
hash = 7fdf27a3924d5530
allow_duplicate_hash = true
pre $text = 0
pre $batched = 0
if (!$goals && !$intel)
    pre $sprites_before_markers = $sprites_before_markers + 1
endif
run = CommandList_Sprite_Both

[ShaderOverride_SpritesBatched]
hash = 55642c752fa497f2
allow_duplicate_hash = true
pre $text = 0
pre $batched = 1
run = CommandList_Sprite_Both
post $batched = 0

[ShaderOverride_BlockColourBatched]
hash = 07a16668ff270883
allow_duplicate_hash = true
pre $pre = 1
post $pre = 0
pre $allow_depth = $depth_map
run = CommandList_UseDepth_Both
post $allow_depth = 0

[ShaderOverride_MenuAndHUDIcons]
hash = 9ceefab76c72863a
allow_duplicate_hash = true
run = CommandList_AllMarkersDrawn

[CommandList_Crosshair_Both]
pre $marker_type = $crosshair
if ($allow_depth && $pre)
    ; treat crosshair as one element
    pre $new_sprites = 1
    pre $crosshairs = $crosshairs + 1
endif
run = CommandList_StartDepth_Both
if (!$pre)
    post run = CommandList_EndDepth_Post
    post $marker_type = 0
endif

[PresetTriRotor]
convergence = 75

[TextureOverride_Crosshair1]
hash = 4a15fb60
run = CommandList_Crosshair_Both

[TextureOverride_Crosshair2]
hash = c11fb4b5
run = CommandList_Crosshair_Both

[TextureOverride_Crosshair3]
hash = 484ed273
run = CommandList_Crosshair_Both

[TextureOverride_Crosshair4]
hash = 9941830c
run = CommandList_Crosshair_Both

[TextureOverride_Laser]
hash = 4ea3c841
run = CommandList_Crosshair_Both

[TextureOverride_CrosshairTriRotorBox]
hash = 0a5f1dbb
run = CommandList_Crosshair_Both
preset = PresetTriRotor

[CommandList_BlobMarkerStart_Both]
; Only increment if we're not already drawing a goal
if ($allow_depth && !$at_depth)
    pre $req_blobs = $new_sprites
endif
run = CommandList_StartDepth_Both

; These textures are in the order they are drawn, 
; but each are optional in different circumstances the 
; only consistent thing is the blob is drawn last

[CommandList_GoalStart_Both]
; Partial goal drawn
if ($at_depth && $at_depth % 1 != 0 && $new_sprites % 1 != 0 && $pre)
    pre $at_depth = $at_depth + $new_sprites
    pre $goals = $goals + $new_sprites
endif
if ($allow_depth && !$at_depth && $pre)
    pre $goals = $goals + $new_sprites
    pre $is_goal = 1
endif
run = CommandList_BlobMarkerStart_Both

[CommandList_IntelStart_Both]
if ($allow_depth)
    if ($pre)
        pre run = CommandList_IntelStart_Pre
    endif
    run = CommandList_BlobMarkerStart_Both
endif

[CommandList_IntelStart_Pre]
; last text was 'unknown', we now know it was even split, so finish the job.
if ($unknown_chars && $unknown_chars == $chars_back / 2)
    run = CommandList_SaveUnknownChars_Pre
    $new_chars = 0
endif
; detected a new intel
if (!$at_depth)
    $intel = $intel + $new_sprites
endif
; an intel being drawn as part of a goal batch
if ($at_depth && $at_depth < $new_sprites)
    ; number of sprites has changed, which means intel text was batched with a single goal
    if ($text_cache_prev && $text_cache_prev != $\Configs\Array.ini\value)
        $\Configs\Array.ini\index = $texts - $at_depth
        run = CommandList\Configs\Array.ini\Get
        $batched_intel_text = $\Configs\Array.ini\value - $text_cache_prev
        ; Restore original cache value
        $\Configs\Array.ini\value = $text_cache_prev
        run = CommandList\Configs\Array.ini\Set
    endif
    ; only increment intel if intel text batched with goal
    ; or batch drew goals and intel, and the totals match the cache
    ; otherwise it will be done by the intel text draw
    if ($batched_intel_text > 0 || $at_depth > 1)
        $intel = $intel + $new_sprites - $at_depth
        $texts = $texts + 1
        $batched_intel_text = 0
    endif
    $at_depth = $new_sprites
endif
$text_cache_prev = 0
; in an expected intel after text
if ($at_depth && !$is_goal)
    ; pretend we're not at depth to trigger new depth sample
    $at_depth = 0
    ; No longer matters that we're intel, so do this to prevent deco box sample
    $is_goal = 1
endif

[CommandList_BlobMarkerEnd_Both]
; Used for lots of things in the HUD, not just markers
if ($allow_depth && $at_depth)
    if ($pre)
        pre $blobs = $blobs + $new_sprites
    endif
    run = CommandList_UseDepth_Both
    if ($blobs >= $req_blobs && !$pre)
        post run = CommandList_EndDepth_Post
        post $req_blobs = 0
        post $blobs = 0
    endif
endif

[CommandList_AllMarkersDrawn]
; intel has disappeared
if ($intel_prev > $intel)
    $intel_prev = 0
endif

[TextureOverride_GoalOuter]
hash = 89951c97
; start of goal while not transitioning off-screen
run = CommandList_GoalStart_Both

[TextureOverride_GoalCentre]
hash = b5e01512
; optional part of a goal
run = CommandList_UseDepth_Both

[TextureOverride_GoalArrow]
hash = 73b56261
; start of a goal when transitioning off-screen
run = CommandList_GoalStart_Both
; extra blob is drawn when an arrow is drawn
if ($allow_depth && $at_depth && $pre)
    pre $req_blobs = $req_blobs + $new_sprites
    pre $goal_arrows = $goal_arrows + $new_sprites
endif

[TextureOverride_DecoText1]
hash = 88cac974
; start of intel when visible, part of centre goal alternates with DecoText2
run = CommandList_IntelStart_Both

[TextureOverride_DecoText2]
hash = d5f8a4d4
; start of intel when visible, part of centre goal alternates with DecoText1
run = CommandList_IntelStart_Both

[TextureOverride_DecoBox]
hash = 873db96b
; start of intel when appearing, part of centre goal
run = CommandList_IntelStart_Both

[TextureOverride_BlueBlob]
hash = d860b2d5
run = CommandList_BlobMarkerEnd_Both

[TextureOverride_BlueBlobAlt]
hash = 6DAD593D
run = CommandList_BlobMarkerEnd_Both

[TextureOverride_ExecuteMarkStart]
hash = 90d0b12f
pre $marker_type = $execute
if ($allow_depth)
    post $executes = $executes + $new_sprites
endif
run = CommandList_StartDepth_Both
post $marker_type = 0

[TextureOverride_ExecuteMarkMiddle]
hash = 62de70a7
run = CommandList_UseDepth_Both

[TextureOverride_ExecuteMarkHelmetBack]
hash = ff7a9e37
run = CommandList_UseDepth_Both

[TextureOverride_ExecuteMarkHelmetFront]
hash = af41cd04
run = CommandList_UseDepth_Both

[TextureOverride_ExecuteMarkEnd]
hash = 2971c2e6
run = CommandList_UseDepth_Both
post run = CommandList_EndDepth_Post

[TextureOverride_CounterBG]
hash = BB37AFCA
run = CommandList_AllMarkersDrawn

[CommandList_DumpTexture]
dump = dump_tex dds mono ps-t0