; [HUD elements at Depth]
; There are several types of element we want to push to depth:
; - Light flare: Drawn at screen depth so we use the depth buffer to push each to depth.
;                Accesses the depth buffer directly via a different mechanism.
; - Crosshair:   Sprites which always use the depth from the middle(ish) of the screen.
; - Centre goal: These have text and several sprites including a DecoBox. 
;                The text is drawn mid-way so we know it's included.
;                It ends with a single BlueBlob sprite.
; - Edge goal:   These are like centre goals, but have an extra arrow sprite and no text.
;                They have 2 BlueBlob sprites drawn at the end because of the arrow.
; - Execute:     These are 3 simple sprites drawn in order, but the depth is sampled
;                below to try and hit the target, instead of going over their head.
; - Intel:       These have a DecoBox, but the text is drawn before and first per frame.
;                We use the previous frame's behaviour to include this text each frame.
;
; With the exception of light flares, these are all 'Markers'. 
;
; The philosophy is to sample depth with a custom shader to a custom resource, then 
; re-use that same depth value for all parts of a marker until a known endpoint is 
; reached for that marker. 
;
; To that end, we have StartDepth, UseDepth and EndDepth which are triggered when 
; appropriate by TextureOverrides for sprites and ShaderOverrides for text, 
; because text textures are generated at runtime and don't have a fixed hash.
;
; Both text and sprites can be batched, meaning up to 24 can be drawn in one draw call.
; We calculate the depth for each quad in this batch, and hope that subsequent batches 
; are drawn in the same order to re-use the depth with the same index. 
;
; Text is also drawn twice, first a blurred background and then the crisp foreground.
; Batching is a problem for Text, because it draws characters separately, meaning more 
; than one depth is recorded for each marker (throwing off the indexing).

[Constants]
global $show_depth=0
; Variables to keep track of what's happening
global $allowDepth=0
global $at_depth=0
global $drawn_elements=0
global $goals=0
global $blobs=0
global $num_texts=0
global $num_sprites=0
global $intel_texts=0
global $centre_goals=0
global $marker_boxes=0
; Special cases for custom shader
global $batched=0
global $text=0
global $tracker_type=0
global $crosshair=1
global $execute_mark=2

[Present]
; shouldn't be needed, just in case...
$at_depth=0
$goals=0
; process last frame behaviour
$intel_texts = $marker_boxes - $centre_goals
$marker_boxes=0
$centre_goals=0

[KeyToggleDepth]
type=cycle
Key=VK_OEM_2
$show_depth=1,0

[ResourceDepthBuffer]

[ResourceMatrices]

[Resource1x1]
type=Texture2D
width=1
height=1
format=R32_FLOAT
mips=1
array=1
msaa=1

[ResourceDepthValue]
type=RWStructuredBuffer
; 4 * 6 = 24 : the number of scaleform elements
stride=4
array=6

[CommandListUseDepthBuffer]
vs-t10=ResourceDepthBuffer

[CommandListSetDepthVariables]
run=CommandListUseDepthBuffer
vs-cb11=ResourceMatrices

[CustomShaderSampleDepth]
vs=ShaderFixes/depth_adjust_quad_vs.hlsl
ps=ShaderFixes/depth_adjust_quad_ps.hlsl
run=CommandListCalculateDepth

[CustomShaderSampleDepthBatched]
vs=ShaderFixes/depth_adjust_quad_vs_batched.hlsl
ps=ShaderFixes/depth_adjust_quad_ps.hlsl
run=CommandListCalculateDepth

[CommandListCalculateDepth]
run=BuiltInCommandListUnbindAllRenderTargets
pre w3=$tracker_type
post w3=0
post $tracker_type=0
vs-t13=copy vb0
ps-cb11=ResourceMatrices
ps-t10=ResourceDepthBuffer
; must set o0 BEFORE ps-u*
o0=set_viewport Resource1x1
ps-u1=ResourceDepthValue
post ps-u1=null
draw=from_caller

[ShaderOverride_DepthSource]
hash=29b5047597d81be1
post ResourceDepthBuffer=copy ps-t0
post ResourceMatrices=copy ps-cb11
post run=CommandListDisplayDepth

[ShaderOverride_DepthSourceSonar]
hash=5fe6d8164825fe0e
post ResourceDepthBuffer=copy ps-t1
post ResourceMatrices=copy ps-cb11
post run=CommandListDisplayDepth

[CommandListDisplayDepth]
;if ($show_depth)
;Resource\Addons\debug_2d.ini\Debug2D=ResourceDepthBuffer
;ps-cb11=ResourceMatrices
;endif

[CommandListStartDepth]
if ($allowDepth && !$at_depth)
	if ($batched)
        run=CustomShaderSampleDepthBatched
	else
        run=CustomShaderSampleDepth
	endif
	pre $at_depth=1
endif
run=CommandListUseDepth

[CommandListUseDepth]
if ($allowDepth && $at_depth)
	; use_depth
	x3=1
	post x3=0
	pre vs-t14=ResourceDepthValue
	post vs-t14=null
endif

[CommandListEndDepth]
if ($allowDepth && $at_depth)
	post clear=ResourceDepthValue
	post $at_depth=0
	post $num_texts=0
endif

[ShaderOverride_LightFlares]
hash=c4c52320554d1ee9
run=CommandListUseDepthBuffer
vs-t13=copy vb0

[CommandListText]
; not useful because it's characters not strings
;pre $drawn_elements = vertex_count / 6
; For now, always 1
pre $drawn_elements = 1
pre $allowDepth=1
if ($intel_texts > 0)
	run=CommandListGoalStart
	post $num_texts = $num_texts + 1
	if ($num_texts == 2)
		post $intel_texts = $intel_texts - $drawn_elements
		post $num_texts = 0
	endif
else if ($centre_goals < $goals)
	run=CommandListUseDepth
	post $num_texts = $num_texts + 1
	if ($num_texts == 2)
		post $centre_goals = $centre_goals + $drawn_elements
		post $num_texts = 0
	endif
endif
;post Resource\Addons\debug_cb.ini\debugcb=copy ResourceDepthValue
post $allowDepth=0

[ShaderOverride_Text]
hash=6f56e2eb15c63f14
allow_duplicate_hash=true
$text=1
$batched=0
run=CommandListText

[ShaderOverride_TextBatched]
hash=9fe114e79584a0ac
allow_duplicate_hash=true
$text=1
$batched=1
run=CommandListText

[CommandListSprite]
pre $drawn_elements = vertex_count / 6
pre $allowDepth=1
post $allowDepth=1
checktextureoverride=ps-t0
pre $allowDepth=0
post $allowDepth=0

[ShaderOverride_Sprites]
hash=7fdf27a3924d5530
allow_duplicate_hash=true
$text=0
$batched=0
run=CommandListSprite

[ShaderOverride_SpritesBatched]
hash=55642c752fa497f2
allow_duplicate_hash=true
$text=0
$batched=1
run=CommandListSprite

[ShaderOverride_BlockColourBatched]
hash=07a16668ff270883
allow_duplicate_hash=true
run=CommandListSetDepthVariables
vs-cb11=ResourceMatrices

[CommandListCrosshair]
$tracker_type = $crosshair
run=CommandListStartDepth
run=CommandListEndDepth

[PresetTriRotor]
convergence = 75

[TextureOverride_Crosshair1]
hash=4a15fb60
run=CommandListCrosshair
[TextureOverride_Crosshair2]
hash=c11fb4b5
run=CommandListCrosshair
[TextureOverride_Crosshair3]
hash=484ed273
run=CommandListCrosshair
[TextureOverride_Crosshair4]
hash=9941830c
run=CommandListCrosshair
[TextureOverride_CrosshairTriRotorBox]
hash=0a5f1dbb
run=CommandListCrosshair
preset=PresetTriRotor

[CommandListGoalStart]
; Only increment if we're not already drawing a goal
if ($allowDepth && !$at_depth)
	pre $blobs=1
	pre $goals = $goals + $drawn_elements
endif
run=CommandListStartDepth

[TextureOverride_DecoText1]
hash=88cac974
run=CommandListGoalStart
[TextureOverride_DecoText2]
hash=d5f8a4d4
run=CommandListGoalStart
[TextureOverride_GoalOuter]
hash=89951c97
run=CommandListGoalStart

[TextureOverride_GoalCentre]
hash=b5e01512
run=CommandListUseDepth
[TextureOverride_GoalArrow]
hash=73b56261
run=CommandListUseDepth
$blobs = $blobs + 1
[TextureOverride_DecoBox]
hash=873db96b
$marker_boxes = $marker_boxes + $drawn_elements
run=CommandListUseDepth

[TextureOverride_BlueBlob]
hash=d860b2d5
; Used for lots of things in the HUD, not just markers
if ($allowDepth && $at_depth)
	pre $num_sprites = $num_sprites + 1
	run=CommandListUseDepth
	if ($num_sprites == $blobs)
		run=CommandListEndDepth
		$blobs=0
		$num_sprites=0
	endif
endif

[TextureOverride_ExecuteMarkStart]
hash=90d0b12f
$tracker_type = $execute_mark
run=CommandListStartDepth
[TextureOverride_ExecuteMarkMiddle]
hash=62de70a7
run=CommandListUseDepth
[TextureOverride_ExecuteMarkEnd]
hash=2971c2e6
run=CommandListUseDepth
run=CommandListEndDepth