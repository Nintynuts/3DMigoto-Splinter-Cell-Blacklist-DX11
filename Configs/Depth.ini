; [HUD elements at Depth]
; There are several types of element we want to push to depth:
; - Light flare: Drawn at screen depth so we use the depth buffer to push each to depth.
;                Accesses the depth buffer directly via a different mechanism.
; - Crosshair:   Sprites which always use the depth from the middle(ish) of the screen.
; - Centre goal: These have text and several sprites including a DecoBox. 
;                The text is drawn mid-way so we know it's included.
;                It ends with a single BlueBlob sprite.
; - Edge goal:   These are like centre goals, but have an extra arrow sprite and no text.
;                They have 2 BlueBlob sprites drawn at the end because of the arrow.
; - Execute:     These are 3 simple sprites drawn in order, but the depth is sampled
;                below to try and hit the target, instead of going over their head.
; - Intel:       These have a DecoBox, but the text is drawn before and first per frame.
;                We use the previous frame's behaviour to include this text each frame.
;
; With the exception of light flares, these are all 'Markers'. 
;
; The philosophy is to sample depth with a custom shader to a custom resource, then 
; re-use that same depth value for all parts of a marker until a known endpoint is 
; reached for that marker. 
;
; To that end, we have StartDepth, UseDepth and EndDepth which are triggered when 
; appropriate by TextureOverrides for sprites and ShaderOverrides for text, 
; because text textures are generated at runtime and don't have a fixed hash.
;
; Both text and sprites can be batched, meaning up to 24 can be drawn in one draw call.
; We calculate the depth for each quad in this batch, and hope that subsequent batches 
; are drawn in the same order to re-use the depth with the same index. 
;
; Text is also drawn twice, first a blurred background and then the crisp foreground.
; Batching is a problem for Text, because it draws characters separately, meaning more 
; than one depth is recorded for each marker (throwing off the indexing).

[Constants]
global $show_depth=0
; Variables to keep track of what's happening
global $depth_map=0
global $allow_depth=0
global $at_depth=0
global $new_chars=0
global $new_sprites=0
global $num_blobs=0
global $texts=0
global $markers=0
global $goals=0
global $blobs=0
global $is_front_text=0
global $unexpected_chars=0
global $chars=0
global $chars_temp=0
global $chars_front=0
global $chars_back=0
global $new_texts=0
global $new_texts_front=0
global $new_texts_back=0
global $num_text_draws=0
global $partial_text_draws=0
global $intel_texts=0
global $goal_texts=0
global $marker_boxes=0
; Special cases for custom shader
global $batched=0
global $text=0
global $tracker_type=0
global $crosshair=1
global $execute_mark=2
; for debugging (not changed)
global $front_back_match=1
global $split_back_front=1
global $split_front_1_batched=1
global $split_front_1=1
global $split_front_2=1
global $split_back=0
global $back=0

[Present]
; shouldn't be needed, just in case...
$at_depth=0
$is_front_text=0
$partial_text_draws=0
$chars=0
$chars_front=0
$chars_back=0
$new_texts=0
$new_texts_front=0
$new_texts_back=0
; process last frame behaviour
$intel_texts = $marker_boxes - $goal_texts
if ($unexpected_chars > 0)
	run=CommandListSaveUnexpectedChars
endif
; reset counters
$depth_map=0
$texts=0
$markers=0
$goals=0
$marker_boxes=0
$goal_texts=0
Resource\Addons\debug_cb.ini\debugcb=copy ResourceDepthValue

[KeyToggleDepth]
type=cycle
Key=VK_OEM_2
$show_depth=1,0

[ResourceDepthBuffer]

[ResourceMatrices]

[Resource1x1]
type=Texture2D
width=1
height=1
format=R32_FLOAT
mips=1
array=1
msaa=1

[ResourceDepthValue]
type=RWStructuredBuffer
stride=16
array=16

[CommandListUseDepthBuffer]
vs-t10=ResourceDepthBuffer

[CommandListSetDepthVariables]
run=CommandListUseDepthBuffer
vs-cb11=ResourceMatrices

[CustomShaderSampleDepth]
vs=ShaderFixes/depth_adjust_quad_vs.hlsl
ps=ShaderFixes/depth_adjust_quad_ps.hlsl
run=CommandListCalculateDepth

[CustomShaderSampleDepthBatched]
vs=ShaderFixes/depth_adjust_quad_vs_batched.hlsl
ps=ShaderFixes/depth_adjust_quad_ps.hlsl
run=CommandListCalculateDepth

[CommandListCalculateDepth]
run=BuiltInCommandListUnbindAllRenderTargets
; marker_index
y3 = $markers
post y3 = 0
; num_chars
$\configs\array.ini\index = $markers
run=CommandList\configs\array.ini\Get
z3 = $\configs\array.ini\value
post z3 = 0
; tracker_type
w3 = $tracker_type
post w3 = 0
; run custom shader
vs-t13=copy vb0
ps-cb11=ResourceMatrices
ps-t10=ResourceDepthBuffer
; must set o0 BEFORE ps-u*
o0=set_viewport Resource1x1
ps-u1=ResourceDepthValue
post ps-u1=null
draw=from_caller

[ShaderOverride_DepthSource]
hash=29b5047597d81be1
post ResourceDepthBuffer=copy ps-t0
post ResourceMatrices=copy ps-cb11
post $depth_map=1
post run=CommandListDisplayDepth

[ShaderOverride_DepthSourceSonar]
hash=5fe6d8164825fe0e
post ResourceDepthBuffer=copy ps-t1
post ResourceMatrices=copy ps-cb11
post $depth_map=1
post run=CommandListDisplayDepth

[CommandListDisplayDepth]
;if ($show_depth)
;Resource\Addons\debug_2d.ini\Debug2D=ResourceDepthBuffer
;ps-cb11=ResourceMatrices
;endif

[CommandListStartDepth]
if ($allow_depth && !$at_depth)
	if ($batched)
        run=CustomShaderSampleDepthBatched
	else
        run=CustomShaderSampleDepth
	endif
	pre $at_depth=1
endif
run=CommandListUseDepth

[CommandListUseDepth]
if ($allow_depth && $at_depth)
	; use_depth
	x3=1
	post x3=0
	; marker_index
	y3=$markers
	post y3=0
	pre vs-t14=ResourceDepthValue
	post vs-t14=null
endif

[CommandListEndDepth]
if ($allow_depth && $at_depth)
	; If we had a marker without text
	if ($texts < $markers)
		$text = $markers
		$\configs\array.ini\index = $markers
		$\configs\array.ini\value = 0
		run=CommandList\configs\array.ini\Set
	endif
	; Group batched crosshair elements
	if (!$text && $batched && $tracker_type == $crosshair)
		$new_sprites = 1
	endif
	$markers = $markers + $new_sprites
	$at_depth=0
	$num_text_draws=0
endif

[ShaderOverride_LightFlares]
hash=c4c52320554d1ee9
run=CommandListUseDepthBuffer
vs-t13=copy vb0

[CommandListTextBatched]
; get cached number of characters
$\configs\array.ini\index = $markers + $new_texts
run=CommandList\configs\array.ini\Get
; avoid stack overflow if no more recorded character counts
if ($\configs\array.ini\value != 0)
	; deduct cached length from element count to get remainder
	$chars_temp = $chars_temp - $\configs\array.ini\value
	if ($chars_temp >= 0)
		$new_texts = $new_texts + 1
	endif
	if ($chars_temp > 0)
		; repeat for more text for next goal
		; pre required to prevent stack overflow
		pre run=CommandListTextBatched
	else if ($chars_temp < 0)
		; partial batch, wait for next draw call
		$partial_text_draws = $partial_text_draws + 1
	endif
endif

[CommandListTextInner]
$num_text_draws = $num_text_draws + 1
$new_texts = 0
; append new chars to previous (in case it was partial)
$chars = $chars + $new_chars
if ($new_chars % 1 != 0 || $batched)
	$chars_temp = $chars
	run=CommandListTextBatched
else
	$new_texts = $new_texts + 1
endif
; if text for a marker is complete
if ($is_front_text && $chars == $chars_back && $num_text_draws >= (2 + $partial_text_draws))
	run=CommandListCacheText
endif

[CommandListCacheText]
if (!$batched)
	; drawing text for single goal, save the number of characters
	$\configs\array.ini\index = $texts
	$\configs\array.ini\value = $chars
	run=CommandList\configs\array.ini\Set
endif
$texts = $texts + $new_texts
$chars = 0
$chars_back = 0
$new_texts_back = 0
$num_text_draws = 0
$partial_text_draws = 0

[CommandListSaveUnexpectedChars]
$chars = $unexpected_chars
if (!$batched)
	$new_texts = 1
	run=CommandListCacheText
endif
$unexpected_chars = 0

[CommandListTextFrontOrBack]
$new_chars = vertex_count / 6
; Text usually alternates back/front,
; but sometimes backs are drawn in multiple batches
; then the front is drawn in one batch
$\configs\array.ini\index = $texts
run=CommandList\configs\array.ini\Get
; last text was not split, so update cache like we would have for last text
if ($unexpected_chars != 0 && $new_chars != $\configs\array.ini\value)
	$chars_temp = $chars
	run=CommandListSaveUnexpectedChars
	$chars = $chars_temp
endif
; nothing set, it's the back
if ($chars_back == 0)
	$is_front_text = $back
else
	; back split evenly, batched  (looks like a match, but it's not if partial)
	if ($chars_back == $new_chars && $batched && $num_text_draws == 2 && $partial_text_draws != 0)
		$is_front_text = $split_back
	; front matches back
	else if ($chars_back == $new_chars)
		; matches last frame (or batch with no partials)
		if ($batched || $new_chars == $\configs\array.ini\value)
			$is_front_text = $front_back_match
		else
			; text may have been back split evenly, so wait for next text
			$unexpected_chars = $new_chars
			$is_front_text = $split_back
		endif
	; back split (two backs drawn already)
	else if ($num_text_draws == 2 && $chars_front == 0)
		$is_front_text = $split_back_front
	; front split pt 1 batched (back is complete)
	else if ($batched && $partial_text_draws == 0)
		$is_front_text = $split_front_1_batched	
	; front split pt 1 (back matches previous)
	else if ($chars_back == $\configs\array.ini\value)
		$is_front_text = $split_front_1
	; front split pt 2 (new front + prev front = back)
	else if ($chars_front > 0 && $chars_front + $new_chars == $chars_back)
		$is_front_text = $split_front_2
	else	
		$is_front_text = $split_back
	endif
endif
if ($is_front_text)
	$chars = $chars_front
	$new_texts = $new_texts_front
else	
	$chars = $chars_back
	$new_texts = $new_texts_back
endif
; pass partial num_chars to shader
z3 = $chars
post z3 = 0
run=CommandListUseDepth
post run=CommandListTextInner
if ($is_front_text)
	post $chars_front = $chars
	post $new_texts_front = $new_texts
else
	post $chars_back = $chars
	post $new_texts_back = $new_texts
endif

[CommandListTextIsGoal]
; text while at depth is part of a centre goal
if ($texts < $goals && $at_depth)
	; goals are after intel, so just in case
	; one has disappeared, clear the counter
	$intel_texts = 0
	run=CommandListTextFrontOrBack
	if ($num_text_draws == 0)
		post $goal_texts = $goal_texts + $new_texts
		post $new_texts = 0
	endif
; intel texts are drawn before any sprites
else if ($intel_texts > 0)
	; assume we're at depth
	$at_depth=1
	run=CommandListTextFrontOrBack
	if ($num_text_draws == 0)
		post $intel_texts = $intel_texts - $new_texts
		post $new_texts = 0
	endif
	post $at_depth=0
endif

[CommandListTextAtDepth]
$allow_depth = $depth_map
post $allow_depth = $depth_map
if ($allow_depth)
	run=CommandListTextIsGoal
endif
$allow_depth = 0
post $allow_depth = 0

[ShaderOverride_Text]
hash=6f56e2eb15c63f14
allow_duplicate_hash=true
$text = 1
$batched = 0
run=CommandListTextAtDepth

[ShaderOverride_TextBatched]
hash=9fe114e79584a0ac
allow_duplicate_hash=true
$text = 1
$batched = 1
run=CommandListTextAtDepth

[CommandListSprite]
$new_sprites = vertex_count / 6
$allow_depth = $depth_map
post $allow_depth = $depth_map
checktextureoverride=ps-t0
$allow_depth = 0
post $allow_depth = 0

[ShaderOverride_Sprites]
hash=7fdf27a3924d5530
allow_duplicate_hash=true
$text = 0
$batched = 0
run=CommandListSprite

[ShaderOverride_SpritesBatched]
hash=55642c752fa497f2
allow_duplicate_hash=true
$text = 0
$batched = 1
run=CommandListSprite

[ShaderOverride_BlockColourBatched]
hash=07a16668ff270883
allow_duplicate_hash=true
run=CommandListSetDepthVariables
vs-cb11=ResourceMatrices

[CommandListCrosshair]
$tracker_type = $crosshair
run=CommandListStartDepth
post run=CommandListEndDepth
post $tracker_type = 0

[PresetTriRotor]
convergence = 75

[TextureOverride_Crosshair1]
hash=4a15fb60
run=CommandListCrosshair
[TextureOverride_Crosshair2]
hash=c11fb4b5
run=CommandListCrosshair
[TextureOverride_Crosshair3]
hash=484ed273
run=CommandListCrosshair
[TextureOverride_Crosshair4]
hash=9941830c
run=CommandListCrosshair
[TextureOverride_CrosshairTriRotorBox]
hash=0a5f1dbb
run=CommandListCrosshair
preset=PresetTriRotor

[CommandListGoalStart]
; Only increment if we're not already drawing a goal
if ($allow_depth && !$at_depth)
	$blobs=1
	run=CommandListStartDepth
	$goals = $goals + $new_sprites
endif

[TextureOverride_DecoText1]
hash=88cac974
run=CommandListGoalStart
[TextureOverride_DecoText2]
hash=d5f8a4d4
run=CommandListGoalStart
[TextureOverride_GoalOuter]
hash=89951c97
run=CommandListGoalStart

[TextureOverride_GoalCentre]
hash=b5e01512
run=CommandListUseDepth
[TextureOverride_GoalArrow]
hash=73b56261
run=CommandListUseDepth
if ($allow_depth && $at_depth)
	$blobs = $blobs + 1
endif
[TextureOverride_DecoBox]
hash=873db96b
if ($allow_depth)
	$marker_boxes = $marker_boxes + $new_sprites
	if ($blobs == 0)
		post run=CommandListEndDepth
	endif
endif
run=CommandListUseDepth

[TextureOverride_BlueBlob]
hash=d860b2d5
; Used for lots of things in the HUD, not just markers
if ($allow_depth && $at_depth)
	pre $num_blobs = $num_blobs + 1
	run=CommandListUseDepth
	if ($num_blobs == $blobs)
		post run=CommandListEndDepth
		post $blobs=0
		post $num_blobs=0
	endif
endif

[TextureOverride_ExecuteMarkStart]
hash=90d0b12f
$tracker_type = $execute_mark
run=CommandListStartDepth
post $tracker_type = 0
[TextureOverride_ExecuteMarkMiddle]
hash=62de70a7
run=CommandListUseDepth
[TextureOverride_ExecuteMarkEnd]
hash=2971c2e6
run=CommandListUseDepth
post run=CommandListEndDepth